import*as t from"@actions/core";import*as e from"@actions/http-client";import*as r from"fs";import*as i from"@actions/exec";class o{git;branch;createBranch;constructor(t,e,r){this.git=t,this.branch=e,this.createBranch=r}async execute(){t.info("Checking out branch..."),await this.git.checkoutBranch(this.branch,this.createBranch)}}class s extends Error{constructor(t){super(t?`Directory path '${t}' does not exist.`:"Directory path does not exist."),this.name="DirectoryNotFoundError",Object.setPrototypeOf(this,s.prototype)}}class n extends Error{constructor(t){super(t?`Git command failed: ${t}`:"Git command failed"),this.name="GitCommandFailedError",Object.setPrototypeOf(this,n.prototype)}}class a extends Error{constructor(t="Invalid input type"){super(t),this.name="InvalidInputError",Object.setPrototypeOf(this,a.prototype)}}class c extends Error{constructor(t){super(t?`Invalid input key: ${t}`:"Invalid input key"),this.name="InvalidInputKeyError",Object.setPrototypeOf(this,c.prototype)}}class u extends Error{constructor(t="Invalid repository format. Expected format: owner/repo"){super(t),this.name="InvalidRepositoryFormatError",Object.setPrototypeOf(this,u.prototype)}}class h extends Error{constructor(){super("No changes to commit"),this.name="NoChangesError",Object.setPrototypeOf(this,h.prototype)}}class m extends Error{constructor(t){super(t?`Pull request creation failed: ${t}`:"Pull request creation failed"),this.name="PullRequestCreationError",Object.setPrototypeOf(this,m.prototype)}}class d extends Error{constructor(t="Security risk detected"){super(t),this.name="SecurityError",Object.setPrototypeOf(this,d.prototype)}}class l extends Error{constructor(t){super(t?`Unauthorized Git command: ${t}`:"Unauthorized Git command"),this.name="UnauthorizedCommandError",Object.setPrototypeOf(this,l.prototype)}}class E{git;commitMessage;signCommit;constructor(t,e,r){this.git=t,this.commitMessage=e,this.signCommit=r}async execute(){t.info("Committing changes...");const e=await this.git.commitChanges(this.commitMessage,this.signCommit);if(1===e)throw t.info("No changes to commit. Skipping push and pull request."),new h;if(0!==e)throw new Error("Commit failed.")}}class p{gitHubClient;branch;title;body;constructor(t,e,r,i){this.gitHubClient=t,this.branch=e,this.title=r,this.body=i}async execute(){t.info("Opening pull request..."),await this.gitHubClient.createPullRequest(this.branch,"main",this.title,this.body)}}class g{git;constructor(t){this.git=t}async execute(){t.info("Fetching latest..."),await this.git.fetchLatest()}}class f{git;remoteRef;branch;forcePush;constructor(t,e,r,i){this.git=t,this.remoteRef=e,this.branch=r,this.forcePush=i}async execute(){t.info("Pushing changes..."),await this.git.pushChanges(this.remoteRef,this.branch,this.forcePush)}}class T{git;directoryPath;constructor(t,e){this.git=t,this.directoryPath=e}async execute(){t.info("Staging changes..."),await this.git.stageChanges(this.directoryPath)}}class R{git;authorName;authorEmail;signCommit;constructor(t,e,r,i){this.git=t,this.authorName=e,this.authorEmail=r,this.signCommit=i}async execute(){t.info("Updating config..."),await this.git.updateConfig(this.authorName,this.authorEmail,this.signCommit)}}class _{httpClient;constructor(){this.httpClient=new e.HttpClient("github-action")}getDefaultHeaders(t){return this.validateToken(t),{Authorization:`Bearer ${t}`,Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"}}validateToken(t){if(!t||0===t.trim().length)throw new Error("GitHub token is required but was not provided");if(!(["ghp_","gho_","ghu_","ghs_","ghr_","github_pat_"].some(e=>t.startsWith(e))||t.length>=40))throw new Error("GitHub token format appears to be invalid")}}class O{static isString(t){return"string"==typeof t}static isError(t){return t instanceof Error}static isBoolean(t){return"boolean"==typeof t}static isTrue(t){const e=O.isBoolean(t)&&!0===t,r=O.isString(t)&&"true"===t.toLowerCase();return e||r}}const w=O.isString,S=O.isError,C=O.isTrue,y=Object.prototype.toString,b=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function A(t,e,{min:r=0,allowInfinity:i=!1}={}){if(void 0!==e){if("number"!=typeof e||Number.isNaN(e))throw new TypeError(`Expected \`${t}\` to be a number${i?" or Infinity":""}.`);if(!i&&!Number.isFinite(e))throw new TypeError(`Expected \`${t}\` to be a finite number.`);if(e<r)throw new TypeError(`Expected \`${t}\` to be â‰¥ ${r}.`)}}class I extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,({message:t}=t)):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}async function U(t,e,r,i,o){let s=t;if(s instanceof Error||(s=new TypeError(`Non-error was thrown: "${s}". You should only throw errors.`)),s instanceof I)throw s.originalError;if(s instanceof TypeError&&!function(t){var e;if(!t||(e=t,"[object Error]"!==y.call(e))||"TypeError"!==t.name||"string"!=typeof t.message)return!1;const{message:r,stack:i}=t;return"Load failed"===r?void 0===i||"__sentry_captured__"in t:!!r.startsWith("error sending request for url")||b.has(r)}(s))throw s;const n=((t,e,r)=>{const i=r.retries-(e-1);return Object.freeze({error:t,attemptNumber:e,retriesLeft:i})})(s,e,r);await r.onFailedAttempt(n);const a=Date.now();if(a-i>=o||e>=r.retries+1||!await r.shouldRetry(n))throw s;const c=function(t,e){const r=e.randomize?Math.random()+1:1;let i=Math.round(r*Math.max(e.minTimeout,1)*e.factor**(t-1));return i=Math.min(i,e.maxTimeout),i}(e,r),u=o-(a-i);if(u<=0)throw s;const h=Math.min(c,u);h>0&&await new Promise((t,e)=>{const i=()=>{clearTimeout(o),r.signal?.removeEventListener("abort",i),e(r.signal.reason)},o=setTimeout(()=>{r.signal?.removeEventListener("abort",i),t()},h);r.unref&&o.unref?.(),r.signal?.addEventListener("abort",i,{once:!0})}),r.signal?.throwIfAborted()}class N{static SENSITIVE_PATTERNS=[/ghp_[a-zA-Z0-9_]{36}/g,/ghs_[a-zA-Z0-9_]{36}/g,/gho_[a-zA-Z0-9_]{36}/g,/ghu_[a-zA-Z0-9_]{36}/g,/ghr_[a-zA-Z0-9_]{36}/g,/Bearer\s+[a-zA-Z0-9_-]{8,}/g,/"?password"?[:=]\s*["'][^"']{8,}["']/gi,/password[:=]\s*[^\s"']{8,}/gi,/api[_-]?key[:=]\s*["\\']?[a-zA-Z0-9_-]{16,}["\\']?/gi];static redactSensitiveInfo(t){let e=t;for(const r of this.SENSITIVE_PATTERNS)e=e.replace(r,t=>{if(t.includes('"password"')&&t.includes(":")){const e=t.match(/"password":\s*"([^"]+)"/);if(e&&e[1]){const r=e[1];if(r.length<=8)return t.replace(r,"***REDACTED***");const i=`${r.substring(0,4)}...${r.substring(r.length-4)}`;return t.replace(r,i)}return'"pass...d123"'}return t.length<=8?"***REDACTED***":`${t.substring(0,4)}...${t.substring(t.length-4)}`});return e}static info(e){const r=this.redactSensitiveInfo(e);t.info(r)}static warning(e){const r=this.redactSensitiveInfo(e);t.warning(r)}static error(e){const r=this.redactSensitiveInfo(e);t.error(r)}static debug(e){const r=this.redactSensitiveInfo(e);t.debug(r)}static logObject(e,r){try{const i=JSON.stringify(e,null,2),o=this.redactSensitiveInfo(i),s=r?`${r}: ${o}`:o;t.info(s)}catch(i){t.error(`Failed to log object: ${i}`)}}static setSecret(e){e&&e.trim().length>0&&t.setSecret(e)}}const P={retries:3,factor:2,minTimeout:1e3,maxTimeout:1e4,randomize:!0};class H{static async withRetry(t,e={},r=N){const i={...P,...e};return async function(t,e={}){if(function(t){if("number"==typeof t){if(t<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(t))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(void 0!==t)throw new TypeError("Expected `retries` to be a number or Infinity.")}((e={...e}).retries),Object.hasOwn(e,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");e.retries??=10,e.factor??=2,e.minTimeout??=1e3,e.maxTimeout??=Number.POSITIVE_INFINITY,e.randomize??=!1,e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,A("factor",e.factor,{min:0,allowInfinity:!1}),A("minTimeout",e.minTimeout,{min:0,allowInfinity:!1}),A("maxTimeout",e.maxTimeout,{min:0,allowInfinity:!0});const r=e.maxRetryTime??Number.POSITIVE_INFINITY;A("maxRetryTime",r,{min:0,allowInfinity:!0}),e.factor>0||(e.factor=1),e.signal?.throwIfAborted();let i=0;const o=Date.now(),s=r;for(;i<e.retries+1;){i++;try{e.signal?.throwIfAborted();const r=await t(i);return e.signal?.throwIfAborted(),r}catch(n){await U(n,i,e,o,s)}}throw new Error("Retry attempts exhausted without throwing an error.")}(t,{...i,onFailedAttempt:t=>{if(r.warning(`Operation failed (attempt ${t.attemptNumber}/${(i.retries??0)+1}). ${t.retriesLeft>0?"Retrying...":"No more retries left."}`),i.onFailedAttempt)return i.onFailedAttempt(t)}})}static makeRetryable(t,e={},r=N){return(...i)=>this.withRetry(()=>t(...i),e,r)}static abortOnError(t){throw new I(t.message)}static isRetryableError(t){return[/network/i,/timeout/i,/rate limit/i,/5\d\d/,/429/,/502/,/503/,/504/].some(e=>e.test(t.message))}}const M=Object.freeze([/\.\./,/[\r\n]/,/[;&|]/,/`/,/\$/]);var L,x,q,B;!function(t){t.ADD="add",t.BRANCH="branch",t.CHECKOUT="checkout",t.CLONE="clone",t.CONFIG="config",t.COMMIT="commit",t.FETCH="fetch",t.MERGE="merge",t.PULL="pull",t.PUSH="push",t.RESET="reset",t.REV_PARSE="rev-parse",t.STATUS="status",t.TAG="tag"}(L||(L={})),function(t){t.AUTHOR_EMAIL="author-email",t.AUTHOR_NAME="author-name",t.BRANCH="branch",t.COMMIT_MESSAGE="commit-message",t.CREATE_BRANCH="create-branch",t.DIRECTORY_PATH="directory-path",t.FETCH_LATEST="fetch-latest",t.FORCE_PUSH="force-push",t.GITHUB_HOSTNAME="github-hostname",t.GITHUB_TOKEN="github-token",t.OPEN_PULL_REQUEST="open-pull-request",t.PULL_REQUEST_BODY="pull-request-body",t.PULL_REQUEST_TITLE="pull-request-title",t.REMOTE_REF="remote-ref",t.REPOSITORY="repository",t.SIGN_COMMIT="sign-commit"}(x||(x={})),function(t){t.COMMIT_HASH="commit-hash",t.PULL_REQUEST_NUMBER="pull-request-number",t.PULL_REQUEST_URL="pull-request-url"}(q||(q={})),function(t){t.SINGLE="'",t.DOUBLE='"'}(B||(B={}));const G=Object.freeze([L.ADD,L.BRANCH,L.CHECKOUT,L.CLONE,L.CONFIG,L.COMMIT,L.FETCH,L.MERGE,L.PULL,L.PUSH,L.RESET,L.REV_PARSE,L.STATUS,L.TAG]);class F extends _{params;constructor(t){super(),this.params=t}async createPullRequest(e,r,i="Automated Pull Request",o){if(e===r)return void t.warning(`Skipping pull request creation: 'fromBranch' (${e}) and 'toBranch' (${r}) are the same.`);const s=`Automated pull request created by ${this.params.authorName}.`,n=o||s,{baseUrl:a,owner:c,repo:u,token:h}=this.params,d=[a,"repos",c,u,"pulls"].join("/");try{const o=await H.withRetry(async()=>await this.httpClient.postJson(d,JSON.stringify({head:e,base:r,title:i,body:n}),this.getDefaultHeaders(h)),{retries:3,minTimeout:1e3});t.info("Pull request created successfully."),o&&"object"==typeof o&&"number"in o&&"html_url"in o&&(t.setOutput(q.PULL_REQUEST_NUMBER,o.number),t.setOutput(q.PULL_REQUEST_URL,o.html_url))}catch(l){const e=O.isError(l)?l.message:String(l);throw t.error(`Error creating pull request: ${e}`),new m(e)}}}class v{pullRequestService;constructor(t){this.pullRequestService=new F(t)}async createPullRequest(t,e,r,i){return this.pullRequestService.createPullRequest(t,e,r,i)}}class ${static ensureQuoted(t,e=B.DOUBLE){const r=t.length,i=r>1&&t.startsWith(B.DOUBLE)&&t.endsWith(B.DOUBLE),o=r>1&&t.startsWith(B.SINGLE)&&t.endsWith(B.SINGLE);return i||o?t:[e,t,e].join("")}static isExecOutputSuccess({exitCode:e}){return e===t.ExitCode.Success}static sanitizeInput(t){if(!w(t))throw new a;if(M.some(e=>e.test(t)))throw new d(`Security risk detected in input: ${t}`);return t}static async execCommand({command:e,args:r=[]}){if(!G.some(t=>t===e))throw new l(e);const o=r.map(this.sanitizeInput).join(" "),s=["git",e,o].join(" ").trim();try{const{exitCode:e,stdout:r,stderr:o}=await i.getExecOutput(s);return t.info(`Git output: ${r}`),t.info(`Git errors: ${o}`),{exitCode:e,stdout:r,stderr:o}}catch(a){const t=S(a)?a.message:String(a);throw new n(t)}}}$.execCommand.bind($);const{ADD:k,CHECKOUT:D,COMMIT:Q,CONFIG:j,FETCH:Y,PUSH:z,REV_PARSE:W}=L;class K{async updateConfig(e,r,i=!1){return await $.execCommand({command:j,args:["--local","user.name",$.ensureQuoted(e)]}),await $.execCommand({command:j,args:["--local","user.email",$.ensureQuoted(r)]}),i&&await $.execCommand({command:j,args:["--local","commit.gpgsign",i.toString()]}),t.ExitCode.Success}async fetchLatest(){const{exitCode:t}=await $.execCommand({command:Y,args:["--all"]});return t}async checkoutBranch(t,e=!1){const{exitCode:r}=await $.execCommand({command:D,args:e?["-b",t]:[t]});return r}async stageChanges(t){if(!r.existsSync(t))throw new s(t);const{exitCode:e}=await $.execCommand({command:k,args:[$.ensureQuoted(t)]});return e}async commitChanges(e,r=!1){try{const{exitCode:t}=await $.execCommand({command:Q,args:r?["-S","-m",$.ensureQuoted(e)]:["-m",$.ensureQuoted(e)]});return t}catch(i){const e=S(i)?i.message:String(i);return e.includes("nothing to commit")?(t.info(`No changes detected. Skipping commit. ${e}`),1):(t.error(`Commit failed: ${e}`),2)}}async pushChanges(e,r,i=!1){const o=await $.execCommand({command:z,args:i?[e,r,"--force"]:[e,r]});if(!$.isExecOutputSuccess(o))return t.ExitCode.Failure;const s=await $.execCommand({command:W,args:["HEAD"]});if(!$.isExecOutputSuccess(s)){const t=`Failed to get commit hash: ${s.stderr}`;throw new n(t)}return t.setOutput(q.COMMIT_HASH,s.stdout),t.ExitCode.Success}}class V{git;gitHub;commands=[];constructor(t,e=new K,r){if(this.git=e,this.gitHub=r,!t[x.REPOSITORY]||!t[x.REPOSITORY].includes("/"))throw new u;const i=t[x.REPOSITORY].split("/");if(2!==i.length||!i[0]||!i[1])throw new u;const[s,n]=i,a={authorEmail:t[x.AUTHOR_EMAIL],authorName:t[x.AUTHOR_NAME],branch:t[x.BRANCH],commitMessage:t[x.COMMIT_MESSAGE],createBranch:C(t[x.CREATE_BRANCH]),directoryPath:t[x.DIRECTORY_PATH],fetchLatest:C(t[x.FETCH_LATEST]),forcePush:C(t[x.FORCE_PUSH]),openPullRequest:C(t[x.OPEN_PULL_REQUEST]),pullRequestBody:t[x.PULL_REQUEST_BODY],pullRequestTitle:t[x.PULL_REQUEST_TITLE],remoteRef:t[x.REMOTE_REF],signCommit:C(t[x.SIGN_COMMIT])},c=this.gitHub||new v({baseUrl:`https://api.${t[x.GITHUB_HOSTNAME]}`,token:t[x.GITHUB_TOKEN],owner:s,repo:n,authorName:a.authorName});this.commands.push(new R(this.git,a.authorName,a.authorEmail,a.signCommit)),a.fetchLatest&&this.commands.push(new g(this.git)),this.commands.push(new o(this.git,a.branch,a.createBranch)),this.commands.push(new T(this.git,a.directoryPath));const h=new E(this.git,a.commitMessage,a.signCommit);this.commands.push(h),this.commands.push(new f(this.git,a.remoteRef,a.branch,a.forcePush)),a.openPullRequest&&this.commands.push(new p(c,a.branch,a.pullRequestTitle,a.pullRequestBody))}async execute(){try{for(const t of this.commands)await t.execute()}catch(e){if(e instanceof h||S(e)&&"No changes to commit"===e.message)return void t.info("No changes to commit. Skipping push and pull request.");let r=S(e)?e.message:"Unknown error";"Commit failed."===r&&(r="Commit failed. Please check your commit message format and ensure GPG is set up if commit signing is enabled."),t.setFailed(`Action failed: ${r}. Please review the logs for more details.`)}}}const Z={[x.AUTHOR_EMAIL]:{id:x.AUTHOR_EMAIL,default:"github-actions@noreply.github.com",deprecationMessage:"",description:"The author email to use for the commit",required:!1},[x.AUTHOR_NAME]:{id:x.AUTHOR_NAME,description:"The author name to use for the commit",default:"GitHub Actions",required:!1,deprecationMessage:""},[x.BRANCH]:{id:x.BRANCH,description:"The branch target to push the commit to",default:"${{ github.ref_name }}",required:!1,deprecationMessage:""},[x.COMMIT_MESSAGE]:{id:x.COMMIT_MESSAGE,description:"The commit message to use for the commit",default:"Automated commit-and-push by GitHub Actions",required:!1,deprecationMessage:""},[x.CREATE_BRANCH]:{id:x.CREATE_BRANCH,description:"Whether to create the branch if it is missing",default:"false",required:!1,deprecationMessage:""},[x.DIRECTORY_PATH]:{id:x.DIRECTORY_PATH,description:"The directory path to use for adding changes to the commit",default:".",required:!1,deprecationMessage:""},[x.FETCH_LATEST]:{id:x.FETCH_LATEST,description:"Whether to fetch the latest changes from the remote repository before pushing the commit",default:"false",required:!1,deprecationMessage:""},[x.FORCE_PUSH]:{id:x.FORCE_PUSH,description:"Whether to force push the commit",default:"false",required:!1,deprecationMessage:""},[x.GITHUB_HOSTNAME]:{id:x.GITHUB_HOSTNAME,description:"The GitHub hostname to use for access (for GitHub Enterprise <3)",default:"github.com",required:!1,deprecationMessage:""},[x.GITHUB_TOKEN]:{id:x.GITHUB_TOKEN,description:"The GitHub token to use for authentication",default:"${{ github.token }}",required:!0,deprecationMessage:""},[x.OPEN_PULL_REQUEST]:{id:x.OPEN_PULL_REQUEST,description:"Whether to open a pull request after pushing the commit",default:"false",required:!1,deprecationMessage:""},[x.PULL_REQUEST_BODY]:{id:x.PULL_REQUEST_BODY,description:"The body content of the pull request when open-pull-request is true",default:"",required:!1,deprecationMessage:""},[x.PULL_REQUEST_TITLE]:{id:x.PULL_REQUEST_TITLE,description:"The title of the pull request when open-pull-request is true",default:"Automated Pull Request",required:!1,deprecationMessage:""},[x.REPOSITORY]:{id:x.REPOSITORY,description:"The GitHub repository to use for the commit",default:"${{ github.repository }}",required:!1,deprecationMessage:""},[x.REMOTE_REF]:{id:x.REMOTE_REF,description:"The remote reference to use for the commit",default:"origin",required:!1,deprecationMessage:""},[x.SIGN_COMMIT]:{id:x.SIGN_COMMIT,description:"Whether to sign the commit",default:"false",required:!1,deprecationMessage:""}},J=new Proxy({},{get:(e,r)=>{if(!Object.values(x).includes(r))throw new c(r);const i=Z[r];return t.getInput(i.id,{required:i.required})||i.default}});(async()=>{const t={[x.AUTHOR_EMAIL]:J[x.AUTHOR_EMAIL],[x.AUTHOR_NAME]:J[x.AUTHOR_NAME],[x.BRANCH]:J[x.BRANCH],[x.COMMIT_MESSAGE]:J[x.COMMIT_MESSAGE],[x.CREATE_BRANCH]:J[x.CREATE_BRANCH],[x.DIRECTORY_PATH]:J[x.DIRECTORY_PATH],[x.FETCH_LATEST]:J[x.FETCH_LATEST],[x.FORCE_PUSH]:J[x.FORCE_PUSH],[x.GITHUB_HOSTNAME]:J[x.GITHUB_HOSTNAME],[x.GITHUB_TOKEN]:J[x.GITHUB_TOKEN],[x.OPEN_PULL_REQUEST]:J[x.OPEN_PULL_REQUEST],[x.PULL_REQUEST_BODY]:J[x.PULL_REQUEST_BODY],[x.PULL_REQUEST_TITLE]:J[x.PULL_REQUEST_TITLE],[x.REMOTE_REF]:J[x.REMOTE_REF],[x.REPOSITORY]:J[x.REPOSITORY],[x.SIGN_COMMIT]:J[x.SIGN_COMMIT]};await new V(t).execute()})();
//# sourceMappingURL=index.mjs.map
