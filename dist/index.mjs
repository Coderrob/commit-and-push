import*as t from"@actions/core";import*as e from"@actions/http-client";import*as s from"fs";import*as i from"@actions/exec";class r{git;branch;createBranch;constructor(t,e,s){this.git=t,this.branch=e,this.createBranch=s}async execute(){t.info("Checking out branch..."),await this.git.checkoutBranch(this.branch,this.createBranch)}}class o extends Error{constructor(){super("No changes to commit"),this.name="NoChangesError"}}class a extends Error{constructor(t="Invalid input type"){super(t),this.name="InvalidInputError"}}class n extends Error{constructor(t="Security risk detected"){super(t),this.name="SecurityError"}}class c extends Error{constructor(t){super(t?`Unauthorized Git command: ${t}`:"Unauthorized Git command"),this.name="UnauthorizedCommandError"}}class u extends Error{constructor(t){super(t?`Directory path '${t}' does not exist.`:"Directory path does not exist."),this.name="DirectoryNotFoundError"}}class h extends Error{constructor(t){super(t?`Git command failed: ${t}`:"Git command failed"),this.name="GitCommandFailedError"}}class m extends Error{constructor(t){super(t?`Pull request creation failed: ${t}`:"Pull request creation failed"),this.name="PullRequestCreationError"}}class d extends Error{constructor(t="Invalid repository format. Expected format: owner/repo"){super(t),this.name="InvalidRepositoryFormatError"}}class E extends Error{constructor(t){super(t?`Invalid input key: ${t}`:"Invalid input key"),this.name="InvalidInputKeyError"}}class l{git;commitMessage;signCommit;constructor(t,e,s){this.git=t,this.commitMessage=e,this.signCommit=s}async execute(){t.info("Committing changes...");const e=await this.git.commitChanges(this.commitMessage,this.signCommit);if(1===e)throw t.info("No changes to commit. Skipping push and pull request."),new o;if(0!==e)throw new Error("Commit failed.")}}class g{gitHubClient;branch;constructor(t,e){this.gitHubClient=t,this.branch=e}async execute(){t.info("Opening pull request..."),await this.gitHubClient.createPullRequest(this.branch,"main")}}class p{git;constructor(t){this.git=t}async execute(){t.info("Fetching latest..."),await this.git.fetchLatest()}}class T{git;remoteRef;branch;forcePush;constructor(t,e,s,i){this.git=t,this.remoteRef=e,this.branch=s,this.forcePush=i}async execute(){t.info("Pushing changes..."),await this.git.pushChanges(this.remoteRef,this.branch,this.forcePush)}}class C{git;directoryPath;constructor(t,e){this.git=t,this.directoryPath=e}async execute(){t.info("Staging changes..."),await this.git.stageChanges(this.directoryPath)}}class f{git;authorName;authorEmail;signCommit;constructor(t,e,s,i){this.git=t,this.authorName=e,this.authorEmail=s,this.signCommit=i}async execute(){t.info("Updating config..."),await this.git.updateConfig(this.authorName,this.authorEmail,this.signCommit)}}const R=Object.freeze([/\.\./,/[\r\n]/,/[;&|]/,/`/,/\$/]);var O,S,H,A;!function(t){t.ADD="add",t.BRANCH="branch",t.CHECKOUT="checkout",t.CLONE="clone",t.CONFIG="config",t.COMMIT="commit",t.FETCH="fetch",t.MERGE="merge",t.PULL="pull",t.PUSH="push",t.RESET="reset",t.REV_PARSE="rev-parse",t.STATUS="status",t.TAG="tag"}(O||(O={})),function(t){t.AUTHOR_EMAIL="author-email",t.AUTHOR_NAME="author-name",t.BRANCH="branch",t.COMMIT_MESSAGE="commit-message",t.CREATE_BRANCH="create-branch",t.DIRECTORY_PATH="directory-path",t.FETCH_LATEST="fetch-latest",t.FORCE_PUSH="force-push",t.GITHUB_HOSTNAME="github-hostname",t.GITHUB_TOKEN="github-token",t.OPEN_PULL_REQUEST="open-pull-request",t.REMOTE_REF="remote-ref",t.REPOSITORY="repository",t.SIGN_COMMIT="sign-commit"}(S||(S={})),function(t){t.COMMIT_HASH="commit-hash"}(H||(H={})),function(t){t.SINGLE="'",t.DOUBLE='"'}(A||(A={}));const M=Object.freeze([O.ADD,O.BRANCH,O.CHECKOUT,O.CLONE,O.CONFIG,O.COMMIT,O.FETCH,O.MERGE,O.PULL,O.PUSH,O.RESET,O.REV_PARSE,O.STATUS,O.TAG]);class _{static isString(t){return"string"==typeof t}static isError(t){return t instanceof Error}static isBoolean(t){return"boolean"==typeof t}static isTrue(t){const e=_.isBoolean(t)&&!0===t,s=_.isString(t)&&"true"===t.toLowerCase();return e||s}}const I=_.isString,P=_.isError,N=_.isTrue;class w{static ensureQuoted(t,e=A.DOUBLE){const s=t.length,i=s>1&&t.startsWith(A.DOUBLE)&&t.endsWith(A.DOUBLE),r=s>1&&t.startsWith(A.SINGLE)&&t.endsWith(A.SINGLE);return i||r?t:[e,t,e].join("")}static isExecOutputSuccess({exitCode:e}){return e===t.ExitCode.Success}static sanitizeInput(t){if(!I(t))throw new a;if(R.some(e=>e.test(t)))throw new n(`Security risk detected in input: ${t}`);return t}static async execCommand({command:e,args:s=[]}){if(!M.some(t=>t===e))throw new c(e);const r=s.map(this.sanitizeInput).join(" "),o=["git",e,r].join(" ").trim();try{const{exitCode:e,stdout:s,stderr:r}=await i.getExecOutput(o);return t.info(`Git output: ${s}`),t.info(`Git errors: ${r}`),{exitCode:e,stdout:s,stderr:r}}catch(a){const t=P(a)?a.message:String(a);throw new h(t)}}}w.execCommand.bind(w);const{ADD:U,CHECKOUT:b,COMMIT:y,CONFIG:x,FETCH:G,PUSH:B,REV_PARSE:L}=O;class q{async updateConfig(e,s,i=!1){return await w.execCommand({command:x,args:["--global","user.name",w.ensureQuoted(e)]}),await w.execCommand({command:x,args:["--global","user.email",w.ensureQuoted(s)]}),i&&await w.execCommand({command:x,args:["--global","commit.gpgsign",i.toString()]}),t.ExitCode.Success}async fetchLatest(){const{exitCode:t}=await w.execCommand({command:G,args:["--all"]});return t}async checkoutBranch(t,e=!1){const{exitCode:s}=await w.execCommand({command:b,args:e?["-b",t]:[t]});return s}async stageChanges(t){if(!s.existsSync(t))throw new u(t);const{exitCode:e}=await w.execCommand({command:U,args:[w.ensureQuoted(t)]});return e}async commitChanges(e,s=!1){try{const{exitCode:t}=await w.execCommand({command:y,args:s?["-S","-m",w.ensureQuoted(e)]:["-m",w.ensureQuoted(e)]});return t}catch(i){const e=P(i)?i.message:String(i);return e.includes("nothing to commit")?(t.info(`No changes detected. Skipping commit. ${e}`),1):(t.error(`Commit failed: ${e}`),2)}}async pushChanges(e,s,i=!1){const r=await w.execCommand({command:B,args:i?[e,s,"--force"]:[e,s]});if(!w.isExecOutputSuccess(r))return t.ExitCode.Failure;const o=await w.execCommand({command:L,args:["HEAD"]});if(!w.isExecOutputSuccess(o)){const t=`Failed to get commit hash: ${o.stderr}`;throw new h(t)}return t.setOutput(H.COMMIT_HASH,o.stdout),t.ExitCode.Success}}class F{httpClient;constructor(){this.httpClient=new e.HttpClient("github-action")}getDefaultHeaders(t){return{Authorization:`Bearer ${t}`,Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"}}}class D extends F{params;constructor(t){super(),this.params=t}async createPullRequest(e,s,i="Automated Pull Request",r="Automated pull request created by GitHub Action."){if(e===s)return void t.warning(`Skipping pull request creation: 'fromBranch' (${e}) and 'toBranch' (${s}) are the same.`);const{baseUrl:o,owner:a,repo:n,token:c}=this.params,u=[o,"repos",a,n,"pulls"].join("/");try{await this.httpClient.postJson(u,JSON.stringify({head:e,base:s,title:i,body:r}),this.getDefaultHeaders(c)),t.info("Pull request created successfully.")}catch(h){const e=_.isError(h)?h.message:String(h);throw t.error(`Error creating pull request: ${e}`),new m(e)}}}class ${pullRequestService;constructor(t){this.pullRequestService=new D(t)}async createPullRequest(t,e,s,i){return this.pullRequestService.createPullRequest(t,e,s,i)}}class k{git;gitHub;commands=[];constructor(t,e=new q,s){if(this.git=e,this.gitHub=s,!t[S.REPOSITORY]||!t[S.REPOSITORY].includes("/"))throw new d;const i=t[S.REPOSITORY].split("/");if(2!==i.length||!i[0]||!i[1])throw new d;const[o,a]=i,n={authorEmail:t[S.AUTHOR_EMAIL],authorName:t[S.AUTHOR_NAME],branch:t[S.BRANCH],commitMessage:t[S.COMMIT_MESSAGE],createBranch:N(t[S.CREATE_BRANCH]),directoryPath:t[S.DIRECTORY_PATH],fetchLatest:N(t[S.FETCH_LATEST]),forcePush:N(t[S.FORCE_PUSH]),openPullRequest:N(t[S.OPEN_PULL_REQUEST]),remoteRef:t[S.REMOTE_REF],signCommit:N(t[S.SIGN_COMMIT])},c=this.gitHub||new $({baseUrl:`https://api.${t[S.GITHUB_HOSTNAME]}`,token:t[S.GITHUB_TOKEN],owner:o,repo:a});this.commands.push(new f(this.git,n.authorName,n.authorEmail,n.signCommit)),n.fetchLatest&&this.commands.push(new p(this.git)),this.commands.push(new r(this.git,n.branch,n.createBranch)),this.commands.push(new C(this.git,n.directoryPath));const u=new l(this.git,n.commitMessage,n.signCommit);this.commands.push(u),this.commands.push(new T(this.git,n.remoteRef,n.branch,n.forcePush)),n.openPullRequest&&this.commands.push(new g(c,n.branch))}async execute(){try{for(const t of this.commands)await t.execute()}catch(e){if(e instanceof o||P(e)&&"No changes to commit"===e.message)return void t.info("No changes to commit. Skipping push and pull request.");let s=P(e)?e.message:"Unknown error";"Commit failed."===s&&(s="Commit failed. Please check your commit message format and ensure GPG is set up if commit signing is enabled."),t.setFailed(`Action failed: ${s}. Please review the logs for more details.`)}}}const v={[S.AUTHOR_EMAIL]:{id:S.AUTHOR_EMAIL,default:"github-actions@noreply.github.com",deprecationMessage:"",description:"The author email to use for the commit",required:!1},[S.AUTHOR_NAME]:{id:S.AUTHOR_NAME,description:"The author name to use for the commit",default:"GitHub Actions",required:!1,deprecationMessage:""},[S.BRANCH]:{id:S.BRANCH,description:"The branch target to push the commit to",default:"${{ github.ref_name }}",required:!1,deprecationMessage:""},[S.COMMIT_MESSAGE]:{id:S.COMMIT_MESSAGE,description:"The commit message to use for the commit",default:"Automated commit-and-push by GitHub Actions",required:!1,deprecationMessage:""},[S.CREATE_BRANCH]:{id:S.CREATE_BRANCH,description:"Whether to create the branch if it is missing",default:"false",required:!1,deprecationMessage:""},[S.DIRECTORY_PATH]:{id:S.DIRECTORY_PATH,description:"The directory path to use for adding changes to the commit",default:".",required:!1,deprecationMessage:""},[S.FETCH_LATEST]:{id:S.FETCH_LATEST,description:"Whether to fetch the latest changes from the remote repository before pushing the commit",default:"false",required:!1,deprecationMessage:""},[S.FORCE_PUSH]:{id:S.FORCE_PUSH,description:"Whether to force push the commit",default:"false",required:!1,deprecationMessage:""},[S.GITHUB_HOSTNAME]:{id:S.GITHUB_HOSTNAME,description:"The GitHub hostname to use for access (for GitHub Enterprise <3)",default:"github.com",required:!1,deprecationMessage:""},[S.GITHUB_TOKEN]:{id:S.GITHUB_TOKEN,description:"The GitHub token to use for authentication",default:"${{ github.token }}",required:!0,deprecationMessage:""},[S.OPEN_PULL_REQUEST]:{id:S.OPEN_PULL_REQUEST,description:"Whether to open a pull request after pushing the commit",default:"false",required:!1,deprecationMessage:""},[S.REPOSITORY]:{id:S.REPOSITORY,description:"The GitHub repository to use for the commit",default:"${{ github.repository }}",required:!1,deprecationMessage:""},[S.REMOTE_REF]:{id:S.REMOTE_REF,description:"The remote reference to use for the commit",default:"origin",required:!1,deprecationMessage:""},[S.SIGN_COMMIT]:{id:S.SIGN_COMMIT,description:"Whether to sign the commit",default:"false",required:!1,deprecationMessage:""}},Y=new Proxy({},{get:(e,s)=>{if(!Object.values(S).includes(s))throw new E(s);const i=v[s];return t.getInput(i.id,{required:i.required})||i.default}});(async()=>{const t={[S.AUTHOR_EMAIL]:Y[S.AUTHOR_EMAIL],[S.AUTHOR_NAME]:Y[S.AUTHOR_NAME],[S.BRANCH]:Y[S.BRANCH],[S.COMMIT_MESSAGE]:Y[S.COMMIT_MESSAGE],[S.CREATE_BRANCH]:Y[S.CREATE_BRANCH],[S.DIRECTORY_PATH]:Y[S.DIRECTORY_PATH],[S.FETCH_LATEST]:Y[S.FETCH_LATEST],[S.FORCE_PUSH]:Y[S.FORCE_PUSH],[S.GITHUB_HOSTNAME]:Y[S.GITHUB_HOSTNAME],[S.GITHUB_TOKEN]:Y[S.GITHUB_TOKEN],[S.OPEN_PULL_REQUEST]:Y[S.OPEN_PULL_REQUEST],[S.REMOTE_REF]:Y[S.REMOTE_REF],[S.REPOSITORY]:Y[S.REPOSITORY],[S.SIGN_COMMIT]:Y[S.SIGN_COMMIT]};await new k(t).execute()})();
//# sourceMappingURL=index.mjs.map
