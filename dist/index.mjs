import*as t from"@actions/core";import*as e from"@actions/http-client";import*as r from"fs";import*as i from"@actions/exec";class s{git;branch;createBranch;constructor(t,e,r){this.git=t,this.branch=e,this.createBranch=r}async execute(){t.info("Checking out branch..."),await this.git.checkoutBranch(this.branch,this.createBranch)}}class o extends Error{constructor(){super("No changes to commit"),this.name="NoChangesError"}}class n extends Error{constructor(t="Invalid input type"){super(t),this.name="InvalidInputError"}}class a extends Error{constructor(t="Security risk detected"){super(t),this.name="SecurityError",Object.setPrototypeOf(this,a.prototype)}}class c extends Error{constructor(t){super(t?`Unauthorized Git command: ${t}`:"Unauthorized Git command"),this.name="UnauthorizedCommandError"}}class u extends Error{constructor(t){super(t?`Directory path '${t}' does not exist.`:"Directory path does not exist."),this.name="DirectoryNotFoundError"}}class h extends Error{constructor(t){super(t?`Git command failed: ${t}`:"Git command failed"),this.name="GitCommandFailedError"}}class m extends Error{constructor(t){super(t?`Pull request creation failed: ${t}`:"Pull request creation failed"),this.name="PullRequestCreationError"}}class d extends Error{constructor(t="Invalid repository format. Expected format: owner/repo"){super(t),this.name="InvalidRepositoryFormatError"}}class l extends Error{constructor(t){super(t?`Invalid input key: ${t}`:"Invalid input key"),this.name="InvalidInputKeyError"}}class E{git;commitMessage;signCommit;constructor(t,e,r){this.git=t,this.commitMessage=e,this.signCommit=r}async execute(){t.info("Committing changes...");const e=await this.git.commitChanges(this.commitMessage,this.signCommit);if(1===e)throw t.info("No changes to commit. Skipping push and pull request."),new o;if(0!==e)throw new Error("Commit failed.")}}class g{gitHubClient;branch;title;body;constructor(t,e,r,i){this.gitHubClient=t,this.branch=e,this.title=r,this.body=i}async execute(){t.info("Opening pull request..."),await this.gitHubClient.createPullRequest(this.branch,"main",this.title,this.body)}}class p{git;constructor(t){this.git=t}async execute(){t.info("Fetching latest..."),await this.git.fetchLatest()}}class f{git;remoteRef;branch;forcePush;constructor(t,e,r,i){this.git=t,this.remoteRef=e,this.branch=r,this.forcePush=i}async execute(){t.info("Pushing changes..."),await this.git.pushChanges(this.remoteRef,this.branch,this.forcePush)}}class T{git;directoryPath;constructor(t,e){this.git=t,this.directoryPath=e}async execute(){t.info("Staging changes..."),await this.git.stageChanges(this.directoryPath)}}class R{git;authorName;authorEmail;signCommit;constructor(t,e,r,i){this.git=t,this.authorName=e,this.authorEmail=r,this.signCommit=i}async execute(){t.info("Updating config..."),await this.git.updateConfig(this.authorName,this.authorEmail,this.signCommit)}}class w{httpClient;constructor(){this.httpClient=new e.HttpClient("github-action")}getDefaultHeaders(t){return this.validateToken(t),{Authorization:`Bearer ${t}`,Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"}}validateToken(t){if(!t||0===t.trim().length)throw new Error("GitHub token is required but was not provided");if(!(["ghp_","gho_","ghu_","ghs_","ghr_","github_pat_"].some(e=>t.startsWith(e))||t.length>=40))throw new Error("GitHub token format appears to be invalid")}}class _{static isString(t){return"string"==typeof t}static isError(t){return t instanceof Error}static isBoolean(t){return"boolean"==typeof t}static isTrue(t){const e=_.isBoolean(t)&&!0===t,r=_.isString(t)&&"true"===t.toLowerCase();return e||r}}const C=_.isString,S=_.isError,O=_.isTrue,A=Object.prototype.toString,I=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function b(t,e,{min:r=0,allowInfinity:i=!1}={}){if(void 0!==e){if("number"!=typeof e||Number.isNaN(e))throw new TypeError(`Expected \`${t}\` to be a number${i?" or Infinity":""}.`);if(!i&&!Number.isFinite(e))throw new TypeError(`Expected \`${t}\` to be a finite number.`);if(e<r)throw new TypeError(`Expected \`${t}\` to be â‰¥ ${r}.`)}}class y extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,({message:t}=t)):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}async function N(t,e,r,i,s){let o=t;if(o instanceof Error||(o=new TypeError(`Non-error was thrown: "${o}". You should only throw errors.`)),o instanceof y)throw o.originalError;if(o instanceof TypeError&&!function(t){var e;if(!t||(e=t,"[object Error]"!==A.call(e))||"TypeError"!==t.name||"string"!=typeof t.message)return!1;const{message:r,stack:i}=t;return"Load failed"===r?void 0===i||"__sentry_captured__"in t:!!r.startsWith("error sending request for url")||I.has(r)}(o))throw o;const n=((t,e,r)=>{const i=r.retries-(e-1);return Object.freeze({error:t,attemptNumber:e,retriesLeft:i})})(o,e,r);await r.onFailedAttempt(n);const a=Date.now();if(a-i>=s||e>=r.retries+1||!await r.shouldRetry(n))throw o;const c=function(t,e){const r=e.randomize?Math.random()+1:1;let i=Math.round(r*Math.max(e.minTimeout,1)*e.factor**(t-1));return i=Math.min(i,e.maxTimeout),i}(e,r),u=s-(a-i);if(u<=0)throw o;const h=Math.min(c,u);h>0&&await new Promise((t,e)=>{const i=()=>{clearTimeout(s),r.signal?.removeEventListener("abort",i),e(r.signal.reason)},s=setTimeout(()=>{r.signal?.removeEventListener("abort",i),t()},h);r.unref&&s.unref?.(),r.signal?.addEventListener("abort",i,{once:!0})}),r.signal?.throwIfAborted()}class H{static SENSITIVE_PATTERNS=[/ghp_[a-zA-Z0-9_]{36}/g,/ghs_[a-zA-Z0-9_]{36}/g,/gho_[a-zA-Z0-9_]{36}/g,/ghu_[a-zA-Z0-9_]{36}/g,/ghr_[a-zA-Z0-9_]{36}/g,/Bearer\s+[a-zA-Z0-9_-]{8,}/g,/"?password"?[:=]\s*["'][^"']{8,}["']/gi,/password[:=]\s*[^\s"']{8,}/gi,/api[_-]?key[:=]\s*["\\']?[a-zA-Z0-9_-]{16,}["\\']?/gi];static redactSensitiveInfo(t){let e=t;for(const r of this.SENSITIVE_PATTERNS)e=e.replace(r,t=>{if(t.includes('"password"')&&t.includes(":")){const e=t.match(/"password":\s*"([^"]+)"/);if(e&&e[1]){const r=e[1];if(r.length<=8)return t.replace(r,"***REDACTED***");const i=`${r.substring(0,4)}...${r.substring(r.length-4)}`;return t.replace(r,i)}return'"pass...d123"'}return t.length<=8?"***REDACTED***":`${t.substring(0,4)}...${t.substring(t.length-4)}`});return e}static info(e){const r=this.redactSensitiveInfo(e);t.info(r)}static warning(e){const r=this.redactSensitiveInfo(e);t.warning(r)}static error(e){const r=this.redactSensitiveInfo(e);t.error(r)}static debug(e){const r=this.redactSensitiveInfo(e);t.debug(r)}static logObject(e,r){try{const i=JSON.stringify(e,null,2),s=this.redactSensitiveInfo(i),o=r?`${r}: ${s}`:s;t.info(o)}catch(i){t.error(`Failed to log object: ${i}`)}}static setSecret(e){e&&e.trim().length>0&&t.setSecret(e)}}const M={retries:3,factor:2,minTimeout:1e3,maxTimeout:1e4,randomize:!0};class U{static async withRetry(t,e={},r=H){const i={...M,...e};return async function(t,e={}){if(function(t){if("number"==typeof t){if(t<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(t))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(void 0!==t)throw new TypeError("Expected `retries` to be a number or Infinity.")}((e={...e}).retries),Object.hasOwn(e,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");e.retries??=10,e.factor??=2,e.minTimeout??=1e3,e.maxTimeout??=Number.POSITIVE_INFINITY,e.randomize??=!1,e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,b("factor",e.factor,{min:0,allowInfinity:!1}),b("minTimeout",e.minTimeout,{min:0,allowInfinity:!1}),b("maxTimeout",e.maxTimeout,{min:0,allowInfinity:!0});const r=e.maxRetryTime??Number.POSITIVE_INFINITY;b("maxRetryTime",r,{min:0,allowInfinity:!0}),e.factor>0||(e.factor=1),e.signal?.throwIfAborted();let i=0;const s=Date.now(),o=r;for(;i<e.retries+1;){i++;try{e.signal?.throwIfAborted();const r=await t(i);return e.signal?.throwIfAborted(),r}catch(n){await N(n,i,e,s,o)}}throw new Error("Retry attempts exhausted without throwing an error.")}(t,{...i,onFailedAttempt:t=>{if(r.warning(`Operation failed (attempt ${t.attemptNumber}/${(i.retries??0)+1}). ${t.retriesLeft>0?"Retrying...":"No more retries left."}`),i.onFailedAttempt)return i.onFailedAttempt(t)}})}static makeRetryable(t,e={},r=H){return(...i)=>this.withRetry(()=>t(...i),e,r)}static abortOnError(t){throw new y(t.message)}static isRetryableError(t){return[/network/i,/timeout/i,/rate limit/i,/5\d\d/,/429/,/502/,/503/,/504/].some(e=>e.test(t.message))}}class P extends w{params;constructor(t){super(),this.params=t}async createPullRequest(e,r,i="Automated Pull Request",s){if(e===r)return void t.warning(`Skipping pull request creation: 'fromBranch' (${e}) and 'toBranch' (${r}) are the same.`);const o=`Automated pull request created by ${this.params.authorName}.`,n=s||o,{baseUrl:a,owner:c,repo:u,token:h}=this.params,d=[a,"repos",c,u,"pulls"].join("/");try{await U.withRetry(async()=>{await this.httpClient.postJson(d,JSON.stringify({head:e,base:r,title:i,body:n}),this.getDefaultHeaders(h))},{retries:3,minTimeout:1e3}),t.info("Pull request created successfully.")}catch(l){const e=_.isError(l)?l.message:String(l);throw t.error(`Error creating pull request: ${e}`),new m(e)}}}class L{pullRequestService;constructor(t){this.pullRequestService=new P(t)}async createPullRequest(t,e,r,i){return this.pullRequestService.createPullRequest(t,e,r,i)}}const x=Object.freeze([/\.\./,/[\r\n]/,/[;&|]/,/`/,/\$/]);var q,G,B,F;!function(t){t.ADD="add",t.BRANCH="branch",t.CHECKOUT="checkout",t.CLONE="clone",t.CONFIG="config",t.COMMIT="commit",t.FETCH="fetch",t.MERGE="merge",t.PULL="pull",t.PUSH="push",t.RESET="reset",t.REV_PARSE="rev-parse",t.STATUS="status",t.TAG="tag"}(q||(q={})),function(t){t.AUTHOR_EMAIL="author-email",t.AUTHOR_NAME="author-name",t.BRANCH="branch",t.COMMIT_MESSAGE="commit-message",t.CREATE_BRANCH="create-branch",t.DIRECTORY_PATH="directory-path",t.FETCH_LATEST="fetch-latest",t.FORCE_PUSH="force-push",t.GITHUB_HOSTNAME="github-hostname",t.GITHUB_TOKEN="github-token",t.OPEN_PULL_REQUEST="open-pull-request",t.PULL_REQUEST_BODY="pull-request-body",t.PULL_REQUEST_TITLE="pull-request-title",t.REMOTE_REF="remote-ref",t.REPOSITORY="repository",t.SIGN_COMMIT="sign-commit"}(G||(G={})),function(t){t.COMMIT_HASH="commit-hash"}(B||(B={})),function(t){t.SINGLE="'",t.DOUBLE='"'}(F||(F={}));const v=Object.freeze([q.ADD,q.BRANCH,q.CHECKOUT,q.CLONE,q.CONFIG,q.COMMIT,q.FETCH,q.MERGE,q.PULL,q.PUSH,q.RESET,q.REV_PARSE,q.STATUS,q.TAG]);class ${static ensureQuoted(t,e=F.DOUBLE){const r=t.length,i=r>1&&t.startsWith(F.DOUBLE)&&t.endsWith(F.DOUBLE),s=r>1&&t.startsWith(F.SINGLE)&&t.endsWith(F.SINGLE);return i||s?t:[e,t,e].join("")}static isExecOutputSuccess({exitCode:e}){return e===t.ExitCode.Success}static sanitizeInput(t){if(!C(t))throw new n;if(x.some(e=>e.test(t)))throw new a(`Security risk detected in input: ${t}`);return t}static async execCommand({command:e,args:r=[]}){if(!v.some(t=>t===e))throw new c(e);const s=r.map(this.sanitizeInput).join(" "),o=["git",e,s].join(" ").trim();try{const{exitCode:e,stdout:r,stderr:s}=await i.getExecOutput(o);return t.info(`Git output: ${r}`),t.info(`Git errors: ${s}`),{exitCode:e,stdout:r,stderr:s}}catch(n){const t=S(n)?n.message:String(n);throw new h(t)}}}$.execCommand.bind($);const{ADD:k,CHECKOUT:D,COMMIT:Q,CONFIG:Y,FETCH:z,PUSH:j,REV_PARSE:W}=q;class K{async updateConfig(e,r,i=!1){return await $.execCommand({command:Y,args:["--local","user.name",$.ensureQuoted(e)]}),await $.execCommand({command:Y,args:["--local","user.email",$.ensureQuoted(r)]}),i&&await $.execCommand({command:Y,args:["--local","commit.gpgsign",i.toString()]}),t.ExitCode.Success}async fetchLatest(){const{exitCode:t}=await $.execCommand({command:z,args:["--all"]});return t}async checkoutBranch(t,e=!1){const{exitCode:r}=await $.execCommand({command:D,args:e?["-b",t]:[t]});return r}async stageChanges(t){if(!r.existsSync(t))throw new u(t);const{exitCode:e}=await $.execCommand({command:k,args:[$.ensureQuoted(t)]});return e}async commitChanges(e,r=!1){try{const{exitCode:t}=await $.execCommand({command:Q,args:r?["-S","-m",$.ensureQuoted(e)]:["-m",$.ensureQuoted(e)]});return t}catch(i){const e=S(i)?i.message:String(i);return e.includes("nothing to commit")?(t.info(`No changes detected. Skipping commit. ${e}`),1):(t.error(`Commit failed: ${e}`),2)}}async pushChanges(e,r,i=!1){const s=await $.execCommand({command:j,args:i?[e,r,"--force"]:[e,r]});if(!$.isExecOutputSuccess(s))return t.ExitCode.Failure;const o=await $.execCommand({command:W,args:["HEAD"]});if(!$.isExecOutputSuccess(o)){const t=`Failed to get commit hash: ${o.stderr}`;throw new h(t)}return t.setOutput(B.COMMIT_HASH,o.stdout),t.ExitCode.Success}}class V{git;gitHub;commands=[];constructor(t,e=new K,r){if(this.git=e,this.gitHub=r,!t[G.REPOSITORY]||!t[G.REPOSITORY].includes("/"))throw new d;const i=t[G.REPOSITORY].split("/");if(2!==i.length||!i[0]||!i[1])throw new d;const[o,n]=i,a={authorEmail:t[G.AUTHOR_EMAIL],authorName:t[G.AUTHOR_NAME],branch:t[G.BRANCH],commitMessage:t[G.COMMIT_MESSAGE],createBranch:O(t[G.CREATE_BRANCH]),directoryPath:t[G.DIRECTORY_PATH],fetchLatest:O(t[G.FETCH_LATEST]),forcePush:O(t[G.FORCE_PUSH]),openPullRequest:O(t[G.OPEN_PULL_REQUEST]),pullRequestBody:t[G.PULL_REQUEST_BODY],pullRequestTitle:t[G.PULL_REQUEST_TITLE],remoteRef:t[G.REMOTE_REF],signCommit:O(t[G.SIGN_COMMIT])},c=this.gitHub||new L({baseUrl:`https://api.${t[G.GITHUB_HOSTNAME]}`,token:t[G.GITHUB_TOKEN],owner:o,repo:n,authorName:a.authorName});this.commands.push(new R(this.git,a.authorName,a.authorEmail,a.signCommit)),a.fetchLatest&&this.commands.push(new p(this.git)),this.commands.push(new s(this.git,a.branch,a.createBranch)),this.commands.push(new T(this.git,a.directoryPath));const u=new E(this.git,a.commitMessage,a.signCommit);this.commands.push(u),this.commands.push(new f(this.git,a.remoteRef,a.branch,a.forcePush)),a.openPullRequest&&this.commands.push(new g(c,a.branch,a.pullRequestTitle,a.pullRequestBody))}async execute(){try{for(const t of this.commands)await t.execute()}catch(e){if(e instanceof o||S(e)&&"No changes to commit"===e.message)return void t.info("No changes to commit. Skipping push and pull request.");let r=S(e)?e.message:"Unknown error";"Commit failed."===r&&(r="Commit failed. Please check your commit message format and ensure GPG is set up if commit signing is enabled."),t.setFailed(`Action failed: ${r}. Please review the logs for more details.`)}}}const Z={[G.AUTHOR_EMAIL]:{id:G.AUTHOR_EMAIL,default:"github-actions@noreply.github.com",deprecationMessage:"",description:"The author email to use for the commit",required:!1},[G.AUTHOR_NAME]:{id:G.AUTHOR_NAME,description:"The author name to use for the commit",default:"GitHub Actions",required:!1,deprecationMessage:""},[G.BRANCH]:{id:G.BRANCH,description:"The branch target to push the commit to",default:"${{ github.ref_name }}",required:!1,deprecationMessage:""},[G.COMMIT_MESSAGE]:{id:G.COMMIT_MESSAGE,description:"The commit message to use for the commit",default:"Automated commit-and-push by GitHub Actions",required:!1,deprecationMessage:""},[G.CREATE_BRANCH]:{id:G.CREATE_BRANCH,description:"Whether to create the branch if it is missing",default:"false",required:!1,deprecationMessage:""},[G.DIRECTORY_PATH]:{id:G.DIRECTORY_PATH,description:"The directory path to use for adding changes to the commit",default:".",required:!1,deprecationMessage:""},[G.FETCH_LATEST]:{id:G.FETCH_LATEST,description:"Whether to fetch the latest changes from the remote repository before pushing the commit",default:"false",required:!1,deprecationMessage:""},[G.FORCE_PUSH]:{id:G.FORCE_PUSH,description:"Whether to force push the commit",default:"false",required:!1,deprecationMessage:""},[G.GITHUB_HOSTNAME]:{id:G.GITHUB_HOSTNAME,description:"The GitHub hostname to use for access (for GitHub Enterprise <3)",default:"github.com",required:!1,deprecationMessage:""},[G.GITHUB_TOKEN]:{id:G.GITHUB_TOKEN,description:"The GitHub token to use for authentication",default:"${{ github.token }}",required:!0,deprecationMessage:""},[G.OPEN_PULL_REQUEST]:{id:G.OPEN_PULL_REQUEST,description:"Whether to open a pull request after pushing the commit",default:"false",required:!1,deprecationMessage:""},[G.PULL_REQUEST_BODY]:{id:G.PULL_REQUEST_BODY,description:"The body content of the pull request when open-pull-request is true",default:"",required:!1,deprecationMessage:""},[G.PULL_REQUEST_TITLE]:{id:G.PULL_REQUEST_TITLE,description:"The title of the pull request when open-pull-request is true",default:"Automated Pull Request",required:!1,deprecationMessage:""},[G.REPOSITORY]:{id:G.REPOSITORY,description:"The GitHub repository to use for the commit",default:"${{ github.repository }}",required:!1,deprecationMessage:""},[G.REMOTE_REF]:{id:G.REMOTE_REF,description:"The remote reference to use for the commit",default:"origin",required:!1,deprecationMessage:""},[G.SIGN_COMMIT]:{id:G.SIGN_COMMIT,description:"Whether to sign the commit",default:"false",required:!1,deprecationMessage:""}},J=new Proxy({},{get:(e,r)=>{if(!Object.values(G).includes(r))throw new l(r);const i=Z[r];return t.getInput(i.id,{required:i.required})||i.default}});(async()=>{const t={[G.AUTHOR_EMAIL]:J[G.AUTHOR_EMAIL],[G.AUTHOR_NAME]:J[G.AUTHOR_NAME],[G.BRANCH]:J[G.BRANCH],[G.COMMIT_MESSAGE]:J[G.COMMIT_MESSAGE],[G.CREATE_BRANCH]:J[G.CREATE_BRANCH],[G.DIRECTORY_PATH]:J[G.DIRECTORY_PATH],[G.FETCH_LATEST]:J[G.FETCH_LATEST],[G.FORCE_PUSH]:J[G.FORCE_PUSH],[G.GITHUB_HOSTNAME]:J[G.GITHUB_HOSTNAME],[G.GITHUB_TOKEN]:J[G.GITHUB_TOKEN],[G.OPEN_PULL_REQUEST]:J[G.OPEN_PULL_REQUEST],[G.PULL_REQUEST_BODY]:J[G.PULL_REQUEST_BODY],[G.PULL_REQUEST_TITLE]:J[G.PULL_REQUEST_TITLE],[G.REMOTE_REF]:J[G.REMOTE_REF],[G.REPOSITORY]:J[G.REPOSITORY],[G.SIGN_COMMIT]:J[G.SIGN_COMMIT]};await new V(t).execute()})();
//# sourceMappingURL=index.mjs.map
