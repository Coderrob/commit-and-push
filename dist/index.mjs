import*as t from"@actions/core";import*as e from"@actions/http-client";import*as s from"fs";import*as i from"@actions/exec";class r{git;branch;createBranch;constructor(t,e,s){this.git=t,this.branch=e,this.createBranch=s}async execute(){t.info("Checking out branch..."),await this.git.checkoutBranch(this.branch,this.createBranch)}}class o extends Error{constructor(){super("No changes to commit"),this.name="NoChangesError"}}class a extends Error{constructor(t="Invalid input type"){super(t),this.name="InvalidInputError"}}class n extends Error{constructor(t="Security risk detected"){super(t),this.name="SecurityError"}}class c extends Error{constructor(t){super(t?`Unauthorized Git command: ${t}`:"Unauthorized Git command"),this.name="UnauthorizedCommandError"}}class u extends Error{constructor(t){super(t?`Directory path '${t}' does not exist.`:"Directory path does not exist."),this.name="DirectoryNotFoundError"}}class h extends Error{constructor(t){super(t?`Git command failed: ${t}`:"Git command failed"),this.name="GitCommandFailedError"}}class m extends Error{constructor(t){super(t?`Pull request creation failed: ${t}`:"Pull request creation failed"),this.name="PullRequestCreationError"}}class d extends Error{constructor(t="Invalid repository format. Expected format: owner/repo"){super(t),this.name="InvalidRepositoryFormatError"}}class E extends Error{constructor(t){super(t?`Invalid input key: ${t}`:"Invalid input key"),this.name="InvalidInputKeyError"}}class l{git;commitMessage;signCommit;constructor(t,e,s){this.git=t,this.commitMessage=e,this.signCommit=s}async execute(){t.info("Committing changes...");const e=await this.git.commitChanges(this.commitMessage,this.signCommit);if(1===e)throw t.info("No changes to commit. Skipping push and pull request."),new o;if(0!==e)throw new Error("Commit failed.")}}class g{gitHubClient;branch;constructor(t,e){this.gitHubClient=t,this.branch=e}async execute(){t.info("Opening pull request..."),await this.gitHubClient.createPullRequest(this.branch,"main")}}class p{git;constructor(t){this.git=t}async execute(){t.info("Fetching latest..."),await this.git.fetchLatest()}}class T{git;remoteRef;branch;forcePush;constructor(t,e,s,i){this.git=t,this.remoteRef=e,this.branch=s,this.forcePush=i}async execute(){t.info("Pushing changes..."),await this.git.pushChanges(this.remoteRef,this.branch,this.forcePush)}}class C{git;directoryPath;constructor(t,e){this.git=t,this.directoryPath=e}async execute(){t.info("Staging changes..."),await this.git.stageChanges(this.directoryPath)}}class f{git;authorName;authorEmail;signCommit;constructor(t,e,s,i){this.git=t,this.authorName=e,this.authorEmail=s,this.signCommit=i}async execute(){t.info("Updating config..."),await this.git.updateConfig(this.authorName,this.authorEmail,this.signCommit)}}class R{httpClient;constructor(){this.httpClient=new e.HttpClient("github-action")}getDefaultHeaders(t){return{Authorization:`Bearer ${t}`,Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"}}}class O{static isString(t){return"string"==typeof t}static isError(t){return t instanceof Error}static isBoolean(t){return"boolean"==typeof t}static isTrue(t){const e=O.isBoolean(t)&&!0===t,s=O.isString(t)&&"true"===t.toLowerCase();return e||s}}const S=O.isString,H=O.isError,A=O.isTrue;class M extends R{params;constructor(t){super(),this.params=t}async createPullRequest(e,s,i="Automated Pull Request",r="Automated pull request created by GitHub Action."){if(e===s)return void t.warning(`Skipping pull request creation: 'fromBranch' (${e}) and 'toBranch' (${s}) are the same.`);const{baseUrl:o,owner:a,repo:n,token:c}=this.params,u=[o,"repos",a,n,"pulls"].join("/");try{await this.httpClient.postJson(u,JSON.stringify({head:e,base:s,title:i,body:r}),this.getDefaultHeaders(c)),t.info("Pull request created successfully.")}catch(h){const e=O.isError(h)?h.message:String(h);throw t.error(`Error creating pull request: ${e}`),new m(e)}}}class _{pullRequestService;constructor(t){this.pullRequestService=new M(t)}async createPullRequest(t,e,s,i){return this.pullRequestService.createPullRequest(t,e,s,i)}}const I=Object.freeze([/\.\./,/[\r\n]/,/[;&|]/,/`/,/\$/]);var P,N,w,U;!function(t){t.ADD="add",t.BRANCH="branch",t.CHECKOUT="checkout",t.CLONE="clone",t.CONFIG="config",t.COMMIT="commit",t.FETCH="fetch",t.MERGE="merge",t.PULL="pull",t.PUSH="push",t.RESET="reset",t.REV_PARSE="rev-parse",t.STATUS="status",t.TAG="tag"}(P||(P={})),function(t){t.AUTHOR_EMAIL="author-email",t.AUTHOR_NAME="author-name",t.BRANCH="branch",t.COMMIT_MESSAGE="commit-message",t.CREATE_BRANCH="create-branch",t.DIRECTORY_PATH="directory-path",t.FETCH_LATEST="fetch-latest",t.FORCE_PUSH="force-push",t.GITHUB_HOSTNAME="github-hostname",t.GITHUB_TOKEN="github-token",t.OPEN_PULL_REQUEST="open-pull-request",t.REMOTE_REF="remote-ref",t.REPOSITORY="repository",t.SIGN_COMMIT="sign-commit"}(N||(N={})),function(t){t.COMMIT_HASH="commit-hash"}(w||(w={})),function(t){t.SINGLE="'",t.DOUBLE='"'}(U||(U={}));const b=Object.freeze([P.ADD,P.BRANCH,P.CHECKOUT,P.CLONE,P.CONFIG,P.COMMIT,P.FETCH,P.MERGE,P.PULL,P.PUSH,P.RESET,P.REV_PARSE,P.STATUS,P.TAG]);class y{static ensureQuoted(t,e=U.DOUBLE){const s=t.length,i=s>1&&t.startsWith(U.DOUBLE)&&t.endsWith(U.DOUBLE),r=s>1&&t.startsWith(U.SINGLE)&&t.endsWith(U.SINGLE);return i||r?t:[e,t,e].join("")}static isExecOutputSuccess({exitCode:e}){return e===t.ExitCode.Success}static sanitizeInput(t){if(!S(t))throw new a;if(I.some((e=>e.test(t))))throw new n(`Security risk detected in input: ${t}`);return t}static async execCommand({command:e,args:s=[]}){if(!b.some((t=>t===e)))throw new c(e);const r=s.map(this.sanitizeInput).join(" "),o=["git",e,r].join(" ").trim();try{const{exitCode:e,stdout:s,stderr:r}=await i.getExecOutput(o);return t.info(`Git output: ${s}`),t.info(`Git errors: ${r}`),{exitCode:e,stdout:s,stderr:r}}catch(a){const t=H(a)?a.message:String(a);throw new h(t)}}}y.execCommand.bind(y);const{ADD:x,CHECKOUT:G,COMMIT:B,CONFIG:L,FETCH:q,PUSH:F,REV_PARSE:D}=P;class ${async updateConfig(e,s,i=!1){return await y.execCommand({command:L,args:["--global","user.name",y.ensureQuoted(e)]}),await y.execCommand({command:L,args:["--global","user.email",y.ensureQuoted(s)]}),i&&await y.execCommand({command:L,args:["--global","commit.gpgsign",i.toString()]}),t.ExitCode.Success}async fetchLatest(){const{exitCode:t}=await y.execCommand({command:q,args:["--all"]});return t}async checkoutBranch(t,e=!1){const{exitCode:s}=await y.execCommand({command:G,args:e?["-b",t]:[t]});return s}async stageChanges(t){if(!s.existsSync(t))throw new u(t);const{exitCode:e}=await y.execCommand({command:x,args:[y.ensureQuoted(t)]});return e}async commitChanges(e,s=!1){try{const{exitCode:t}=await y.execCommand({command:B,args:s?["-S","-m",y.ensureQuoted(e)]:["-m",y.ensureQuoted(e)]});return t}catch(i){const e=H(i)?i.message:String(i);return e.includes("nothing to commit")?(t.info(`No changes detected. Skipping commit. ${e}`),1):(t.error(`Commit failed: ${e}`),2)}}async pushChanges(e,s,i=!1){const r=await y.execCommand({command:F,args:i?[e,s,"--force"]:[e,s]});if(!y.isExecOutputSuccess(r))return t.ExitCode.Failure;const o=await y.execCommand({command:D,args:["HEAD"]});if(!y.isExecOutputSuccess(o)){const t=`Failed to get commit hash: ${o.stderr}`;throw new h(t)}return t.setOutput(w.COMMIT_HASH,o.stdout),t.ExitCode.Success}}class k{git;gitHub;commands=[];constructor(t,e=new $,s){if(this.git=e,this.gitHub=s,!t[N.REPOSITORY]||!t[N.REPOSITORY].includes("/"))throw new d;const i=t[N.REPOSITORY].split("/");if(2!==i.length||!i[0]||!i[1])throw new d;const[o,a]=i,n={authorEmail:t[N.AUTHOR_EMAIL],authorName:t[N.AUTHOR_NAME],branch:t[N.BRANCH],commitMessage:t[N.COMMIT_MESSAGE],createBranch:A(t[N.CREATE_BRANCH]),directoryPath:t[N.DIRECTORY_PATH],fetchLatest:A(t[N.FETCH_LATEST]),forcePush:A(t[N.FORCE_PUSH]),openPullRequest:A(t[N.OPEN_PULL_REQUEST]),remoteRef:t[N.REMOTE_REF],signCommit:A(t[N.SIGN_COMMIT])},c=this.gitHub||new _({baseUrl:`https://api.${t[N.GITHUB_HOSTNAME]}`,token:t[N.GITHUB_TOKEN],owner:o,repo:a});this.commands.push(new f(this.git,n.authorName,n.authorEmail,n.signCommit)),n.fetchLatest&&this.commands.push(new p(this.git)),this.commands.push(new r(this.git,n.branch,n.createBranch)),this.commands.push(new C(this.git,n.directoryPath));const u=new l(this.git,n.commitMessage,n.signCommit);this.commands.push(u),this.commands.push(new T(this.git,n.remoteRef,n.branch,n.forcePush)),n.openPullRequest&&this.commands.push(new g(c,n.branch))}async execute(){try{for(const t of this.commands)await t.execute()}catch(e){if(e instanceof o||H(e)&&"No changes to commit"===e.message)return void t.info("No changes to commit. Skipping push and pull request.");let s=H(e)?e.message:"Unknown error";"Commit failed."===s&&(s="Commit failed. Please check your commit message format and ensure GPG is set up if commit signing is enabled."),t.setFailed(`Action failed: ${s}. Please review the logs for more details.`)}}}const v={[N.AUTHOR_EMAIL]:{id:N.AUTHOR_EMAIL,default:"github-actions@noreply.github.com",deprecationMessage:"",description:"The author email to use for the commit",required:!1},[N.AUTHOR_NAME]:{id:N.AUTHOR_NAME,description:"The author name to use for the commit",default:"GitHub Actions",required:!1,deprecationMessage:""},[N.BRANCH]:{id:N.BRANCH,description:"The branch target to push the commit to",default:"${{ github.ref_name }}",required:!1,deprecationMessage:""},[N.COMMIT_MESSAGE]:{id:N.COMMIT_MESSAGE,description:"The commit message to use for the commit",default:"Automated commit-and-push by GitHub Actions",required:!1,deprecationMessage:""},[N.CREATE_BRANCH]:{id:N.CREATE_BRANCH,description:"Whether to create the branch if it is missing",default:"false",required:!1,deprecationMessage:""},[N.DIRECTORY_PATH]:{id:N.DIRECTORY_PATH,description:"The directory path to use for adding changes to the commit",default:".",required:!1,deprecationMessage:""},[N.FETCH_LATEST]:{id:N.FETCH_LATEST,description:"Whether to fetch the latest changes from the remote repository before pushing the commit",default:"false",required:!1,deprecationMessage:""},[N.FORCE_PUSH]:{id:N.FORCE_PUSH,description:"Whether to force push the commit",default:"false",required:!1,deprecationMessage:""},[N.GITHUB_HOSTNAME]:{id:N.GITHUB_HOSTNAME,description:"The GitHub hostname to use for access (for GitHub Enterprise <3)",default:"github.com",required:!1,deprecationMessage:""},[N.GITHUB_TOKEN]:{id:N.GITHUB_TOKEN,description:"The GitHub token to use for authentication",default:"${{ github.token }}",required:!0,deprecationMessage:""},[N.OPEN_PULL_REQUEST]:{id:N.OPEN_PULL_REQUEST,description:"Whether to open a pull request after pushing the commit",default:"false",required:!1,deprecationMessage:""},[N.REPOSITORY]:{id:N.REPOSITORY,description:"The GitHub repository to use for the commit",default:"${{ github.repository }}",required:!1,deprecationMessage:""},[N.REMOTE_REF]:{id:N.REMOTE_REF,description:"The remote reference to use for the commit",default:"origin",required:!1,deprecationMessage:""},[N.SIGN_COMMIT]:{id:N.SIGN_COMMIT,description:"Whether to sign the commit",default:"false",required:!1,deprecationMessage:""}},Y=new Proxy({},{get:(e,s)=>{if(!Object.values(N).includes(s))throw new E(s);const i=v[s];return t.getInput(i.id,{required:i.required})||i.default}});(async()=>{const t={[N.AUTHOR_EMAIL]:Y[N.AUTHOR_EMAIL],[N.AUTHOR_NAME]:Y[N.AUTHOR_NAME],[N.BRANCH]:Y[N.BRANCH],[N.COMMIT_MESSAGE]:Y[N.COMMIT_MESSAGE],[N.CREATE_BRANCH]:Y[N.CREATE_BRANCH],[N.DIRECTORY_PATH]:Y[N.DIRECTORY_PATH],[N.FETCH_LATEST]:Y[N.FETCH_LATEST],[N.FORCE_PUSH]:Y[N.FORCE_PUSH],[N.GITHUB_HOSTNAME]:Y[N.GITHUB_HOSTNAME],[N.GITHUB_TOKEN]:Y[N.GITHUB_TOKEN],[N.OPEN_PULL_REQUEST]:Y[N.OPEN_PULL_REQUEST],[N.REMOTE_REF]:Y[N.REMOTE_REF],[N.REPOSITORY]:Y[N.REPOSITORY],[N.SIGN_COMMIT]:Y[N.SIGN_COMMIT]};await new k(t).execute()})();
//# sourceMappingURL=index.mjs.map
